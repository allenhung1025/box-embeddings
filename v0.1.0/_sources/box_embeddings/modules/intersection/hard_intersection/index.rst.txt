:py:mod:`box_embeddings.modules.intersection.hard_intersection`
===============================================================

.. py:module:: box_embeddings.modules.intersection.hard_intersection


Module Contents
---------------

.. py:function:: hard_intersection(left: box_embeddings.parameterizations.TBoxTensor, right: box_embeddings.parameterizations.TBoxTensor) -> box_embeddings.parameterizations.TBoxTensor

   Hard Intersection operation as a function.

   .. note:: This function can give fipped boxes, i.e. where z[i] > Z[i]

   .. todo:: Add support for broadcasting

   :param left: BoxTensor which is the left operand
   :param right: BoxTensor which is the right operand

   :returns: The resulting BoxTensor obtained by interection.
             It has the same concrete type as the `self` (left operand).

   .. rubric:: Example

   >>> import torch
   >>> from box_embeddings.parameterizations.box_tensor import BoxTensor
   >>> box1_z = [-2.0]*10
   >>> box1_Z = [0.0]*10
   >>> data_x = torch.tensor([box1_z, box1_Z])
   >>> box1 = BoxTensor(torch.tensor([box1_z, box1_Z]))
   >>> box2_z = [1/n for n in range(1, 11)]
   >>> box2_Z = [1 - k for k in reversed(box2_z)]
   >>> box2 = BoxTensor(torch.tensor([box2_z, box2_Z]))
   >>> print(hard_intersection(box1, box2)) # doctest: +NORMALIZE_WHITESPACE
   BoxTensor(z=tensor([1.0000, 0.5000, 0.3333, 0.2500, 0.2000, 0.1667, 0.1429, 0.1250, 0.1111,
       0.1000]),
       Z=tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]))


.. py:class:: HardIntersection

   Bases: :py:obj:`box_embeddings.modules.intersection._intersection._Intersection`

   Hard intersection operation as a Layer/Module


